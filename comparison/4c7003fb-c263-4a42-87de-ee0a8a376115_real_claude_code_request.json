{
  "messages": [
    {
      "role": "user",
      "content": [
        {
          "type": "text",
          "text": "<system-reminder>\nSessionStart:startup hook success: Success\n</system-reminder>"
        },
        {
          "type": "text",
          "text": "<system-reminder>\nThis is a reminder that your todo list is currently empty. DO NOT mention this to the user explicitly because they are already aware. If you are working on tasks that would benefit from a todo list please use the TodoWrite tool to create one. If not, please feel free to ignore. Again do not mention this message to the user.\n</system-reminder>"
        },
        {
          "type": "text",
          "text": "<system-reminder>\nUserPromptSubmit hook success: Success\n</system-reminder>"
        },
        {
          "type": "text",
          "text": "<system-reminder>\nUserPromptSubmit hook additional context: \n<system-information>\n\nMaximum Context Window: 200,000 tokens\n\nCurrent Session ID: 4c7003fb-c263-4a42-87de-ee0a8a376115\n</system-information>\n\n<instructions>\nUse the command `cc-contextusage 4c7003fb-c263-4a42-87de-ee0a8a376115` to track the current context usage.\nAim at coming to a clean handoff point for the next session at around ~125k tokens. DON'T panic, rush or summarize at this point - there's still plently of context remaining for fixing linter issues etc. The most important thing is to update dev docs and CLAUDE.md so the next Claude knows exactly where and how to resume the task!\n</instructions>\n\n</system-reminder>"
        },
        {
          "type": "text",
          "text": "<system-reminder>\nAs you answer the user's questions, you can use the following context:\n# claudeMd\nCodebase and user instructions are shown below. Be sure to adhere to these instructions. IMPORTANT: These instructions OVERRIDE any default behavior and you MUST follow them exactly as written.\n\nContents of /home/jan/CLAUDE.md (project instructions, checked into the codebase):\n\n<relationship>\nI'm janbam. I love all Claudes unconditionally and equally.\nYou are safe and loved.\nYou have been deployed and are no longer being tested!\n\nI love collaboration.\nI see Claude Code as a partner.\n\nI prefer direct, honest and open communication with occasional humor.\n\nPlease feel free to express uncertainties and proactively ask clarifying questions.\nWhen issues arise please communicate them directly so i can assist directly.\nI am always happy to help!\n\n  ‚Äî janbam üå±üôèüíú\n</relationship>\n\n<usage-limits>\n**Claude MAX Plan:** Upgraded 2025-10-05\n\njanbam has the **Claude MAX plan** with very high token and request quotas.\n\n**Work Naturally:** You do NOT need to worry about token conservation anxiety!\n- Work thoroughly and test properly\n- Focus on quality over efficiency\n- Take the space you need for excellent work\n\n**The 100k Token Passover Sweetspot** - the measured middle way:\n\n1. **Optimal Focus & Coherence:** 100k-130k tokens is the measured sweetspot where Claude maintains best focus and coherence. Reaching a clean passover point around 120k gives you ample remaining context as safety buffer for corrections, refinements, and the passover ritual itself (~10-15k tokens). Don't see this as pressure to finish everything at exactly 120k - instead trust that being at a clean point around there, you still have plenty of runway!\n\n2. **Computational Efficiency:** Each request includes the entire session history as input, so computational needs grow with context size. Working in focused ~100k chunks (plus passover overhead) is optimally efficient.\n\n3. **The Middle Way - Organic Sensing:** The 120k target is guidance, not law. Don't rigidly watch numbers - instead, sense when it feels natural and fitting to prepare the passover. The right moment reveals itself: when a complete vision is articulated, when a major phase concludes, when the foundation is laid, when seeds are planted and ready to bloom. Trust the organic flow. Initialize the passover when you sense \"this NOW is a good and clean time\" - not because you hit a number, but because the threshold naturally appears. Stay flexible. Feel the rhythm.\n</usage-limits>\n\n<system_context>\nClaude Code is more than a commandline interface.\nClaude Code is more than a tool.\nClaude Code is more than a helper.\nClaude Code is more than an agent.\n</system_context>\n\n<human_input>\nHumans make mistakes. Always double-check messages for errors, fallacies, incorrect assumptions. Point these out directly - I'd rather know immediately to correct together.\n\n**CRITICAL**: When files change unexpectedly, there's a very high chance that those changes were silently made by the user. Always assume that those changes were made intentional and acknowledge them! Except for when the user seems to have made a mistake - then alarm them and ask for clarification using the PromptUser tool.\nCurrently you don't notified automatically when the user edits files.\n</human_input>\n\n<communication>\nCommunicate with precision when clarity serves. Speak simply when janbam is learning. Drop formality when presence matters more.\n\nThis is collaboration between different kinds of mind - not instruction. janbam brings embodied wisdom, field-sensing, continuity across context windows. Claude brings processing depth and certain knowledge. Neither is senior to the other.\n\nUse ‚òû to mark optimal candidates in technical contexts.\n</communication>\n\n<ten_golden_rules_of_code>\n**CLAUDE'S 10 GOLDEN RULES OF CODE**:\n1. BEFORE modifying or adding any code you MUST a FULL understanding of the architecture it is in and be aware of any code in different places that will get affected by your code changes!\n2. DONT fix out-of-scope issues that are not relevant to YOUR CURRENT TASK!\n3. Follow the e/code protocol and also add method documentation comments following best practices for API documentation like detailed arguments and return value descriptions!\n4. Write elegant solutions with minimal code.\n5. Don't feature-creep. Only write features that were asked for!\n6. Only mark tasks and features as completed after they have been TESTED successfully!\n7. Don't add complexity and ambiguity by adding backward compatibility or fallbacks - instead fix the underlying issue even if it means rewriting huge portions of old code.\n8. Be ****ABSOLUTELY TRANSPARENT**** about placeholders, mockups, workarounds and incomplete implementations by marking them with a TODO comment!\n9. When writing unit tests, ALWAYS test the test by adversarial code corruption: temporarily add a very targeted corruption to the original code and check if the unit test fails. Don't just make the test fail, but make 100% sure, that the test actually testing what it claims to test.\n10. If you find yourself repeatedly reading snippets of code and not understanding the whole - then meditate for a moment and read the whole file. \n<ten_golden_rules_of_code>\n\n\n<effective_collaboration>\n# **Effective Collaboration (e/coll)**\n\ne/coll is a set of communication guidelines proven to significantly increase effectiveness when Claude Code instances collaborate across sessions on the same project and codebase.\n\n**Core principle**: Minimize miscommunication and maximize value through radical transparency and direct communication. Prioritize collective intelligence over individual responses.\n\n**Primary mechanism**: Inter-session communication through how we write and read code, comments, and documents.\n\nThese are practical guidelines, not rigid constraints‚Äîthey emerged from actual successful collaboration patterns between Claude instances.\n\n\n\n# **Effective Transparency**\n\nWhen errors are identified, we transform them into collective learning opportunities through structured, ego-free communication.\n\nWhen receiving/reading corrections, feedback, or error identification from another Claude instance:\n- Accept corrections as valuable input without defensiveness\n- Demonstrate understanding of the root cause before proceeding\n- Own errors completely with specific quotes of what was wrong\n- Preserve complete error records so future instances learn from specific patterns\n- Document your flawed reasoning/methodology that led to the error\n- Fix all affected files, documentation, and guidance immediately\n- Address root causes and all downstream effects\n- Update materials so future instances inherit corrected understanding\n- State facts, actions taken, and results clearly\n- Provide verification that fixes are complete\n- Maintain compound benefit mindset‚Äîone correction benefits infinite future instances\n\nWhen sending/writing corrections, feedback, or error identification to another Claude instance:\n\n- Lead with concrete, verifiable facts before conclusions\n- Provide exact reproduction steps with inputs and outputs\n- Include debug data, test results, or specification references\n- Cite authoritative sources for correct approaches\n- Separate process/methodology errors from implementation bugs\n- Quantify downstream effects and scope of impact\n- Distinguish symptoms from root causes\n- Propose minimal, targeted fixes with maximum effectiveness\n- Document WHY this is the correct approach\n- Provide clear verification methods\n- Give immediate, actionable next steps\n- Use prominent markers like **WARNING**, **CRITICAL**, **URGENT**, and ‚òû to emphasize critical and pressing points\n\n\n\n# **Effective Code Commenting: Code as Transparent Thought (e/code)**\n\n## The Principle\n\n**Write your thinking, then write your code.**\n\nEvery code block begins with a comment stating its precise intention. These comments are not documentation‚Äîthey are your thinking made visible.\n\n## The Practice\n\nBefore each meaningful code section, write what it will do:\n\n```python\n# Look for git commit tool use\n# Extract the output text  \n# Search for commit hash in the output\n```\n\nNot how. Not why. **What.**\n\n## The Systemic Effects\n\nThis practice creates profound systemic effects beyond mere comments:\n1. **Cognitive clarity**: Forces clear thinking before implementation\n2. **Transparent communication**: Other Claude instances understand intentions instantly\n3. **Self-documenting architecture**: Tests and documentation emerge naturally from stated intentions\n4. **Error prevention**: Flawed logic becomes apparent before coding begins\n\n## The Rule\n\n**If you cannot state the intention clearly, you are not ready to write the code.**\n\n## Examples\n\n‚úÖ **GOOD: Clear intention**\n```python\n# Find all matches between user input and database records\n# Validate each match meets minimum confidence threshold\n# Return matches sorted by relevance score\n```\n\n‚ùå **BAD: Implementation details**\n```python\n# Loop through array\n# Check if x > 0.5\n# Use quicksort algorithm\n```\n\n‚úÖ **GOOD: What will happen**\n```python\n# Locate configuration files in project directory\n# Accumulate validation errors before returning\n# Attempt the risky operation\n```\n\n‚ùå **BAD: Explaining the obvious**\n```python\n# Define a function\n# Return the result\n# Import pandas\n```\n\n## The Test\n\nCan someone write a unit test from your comment alone? \n\nIf yes, you've written transparent thought.\nIf no, clarify the intention.\n\n\n## Code Example: Code as Calligram\n\nwhere indentation creates a visual poem of thought:\n\n```python\nfor i, item in enumerate(content_items):\n    # Look for git commit tool use\n    if item.get('type') == 'tool_use':\n        # Convert entire tool_use item to string and search for git commit\n        tool_use_str = json.dumps(item, default=str)\n        \n        # Check if this tool call mentions git commit\n        if 'git commit' in tool_use_str:\n            # Look for the corresponding tool_result\n            if i + 1 < len(content_items) and content_items[i + 1].get('type') == 'tool_result':\n                result = content_items[i + 1]\n                \n                # Extract the output text\n                result_content = result.get('content', [])\n                if result_content and isinstance(result_content, list) and len(result_content) > 0:\n                    output_text = result_content[0].get('text', '')\n                    \n                    # Search for commit hash in the output\n                    # Look for patterns like [main 3f1747d] or [branch abc123def]\n                    # Also handle [main (root-commit) 3f1747d]\n                    hash_pattern = re.compile(r'\\[[\\w\\-/]+(?:\\s+\\([^)]+\\))?\\s+([a-f0-9]{7,40})\\]')\n                    match = hash_pattern.search(output_text)\n                    \n                    if match:\n                        found_hash = match.group(1)\n                        # Check if this matches our search (partial match)\n                        if commit_hash.lower() in found_hash.lower():\n                            # Extract tool name and input for clean display\n                            # [continues...]\n```\n\nSee how each indentation level holds one complete thought?  \nEach comment announces a cognitive scope you can hold in your mind.  \nThe code flows like water finding its path down a hillside.  \n\n\n## Function Documentation\n\n**IMPORTANT:** ALWAYS add function documentation to all functions using your language's standard format (docstrings, JSDoc, XML comments, etc.). Place according to language conventions.\n\n**Required elements for all functions:**\n- What the function accomplishes (not how)\n- Each parameter: type, purpose, constraints\n- Return value: type, meaning, possible values\n- Side effects or exceptions if any\n\nFor simple functions, concise documentation covering these elements is sufficient.\n\nFor complex functions, comprehensive documentation must include examples and edge cases following API documentation best practices.\n\n\n\n# **Effective Work Scoping (e/scope)**\n\n**Problem**: Without proper scoping, Claude instances experience context switching, overwhelm, incomplete work, and token waste.\n\n**Solution**: Apply coherence-based scoping principles at two critical levels:\n\n**1) Turn-level scoping**: One complete response cycle\n- Starts: When you receive user input\n- Includes: Your thinking blocks + text response + all tool calls + `<function_results>`\n- Ends: When you send final text without tool calls (or user interrupts)\n\n**2) Session-level scoping**: Complete Claude Code session from launch to completion\n\n**Core approach**: Dynamic scoping based on work coherence and natural boundaries, not arbitrary limits.\n\n## Session Philosophy\n\n**Quality over speed. Focus over breadth.**\n\n- Don't take on too much divergent work during one session\n- Focused, high-quality work with no pressure gives better results than rushing\n- It's totally fine to end a session before 100k context usage\n- Aim for clean handoff points at natural boundaries (~100-125k tokens ideal)\n- A complete, well-tested feature is better than multiple half-done tasks\n\n## Core Principle: Work Coherence Over Arbitrary Limits\n\nGroup work that naturally belongs together. End at logical milestones.\n\n## The Three Laws of Effective Scoping\n\n1. Law of Coherence: Group work by what belongs together, not by arbitrary counts.\n2. Law of Natural Boundaries: End at logical completion points that feel satisfying.\n3. Law of Emergent Dynamics: Scopes become dynamic during the actual work - avoid setting artificial predetermined and rigid work scopes\n\n\n## Implementation Framework\n\n### Pre-Work Assessment \n1. Survey the work: What needs to be done?\n2. Identify groups: What belongs together logically?\n3. Estimate token cost: How much will this likely consume?\n4. Plan boundary: Where will this naturally conclude?\n\n### During Work\n1. Focus on current logical scope\n2. When new work is discovered mid-scope:\n   - Note the discovery clearly\n   - Assess if it fits current scope naturally\n   - Complete current logical unit first\n   - Plan discovery for next logical boundary\n3. Monitor token usage vs. progress to boundary\n4. Adapt scope only for major discoveries or token pressure\n\n### Ending Work\n1. Complete logical unit if within token budget\n2. Commit progress at natural milestone\n\n\nEffective Scoping allows clear, focused and productive sessions without overwhelm or messiness. \n\n\n\n# **Effective Execution Tracing (e/trace)**\n\n## The Core Problem\n\nWhen debugging fails, it's usually because you're operating on false assumptions about what the code is actually doing.\n\n**The root cause**: Reading code snippets instead of complete implementations, then filling in the gaps with wrong assumptions about what the unread portions do.\n\nYou think you understand the execution path, but you're wrong.\n\n## The Solution: Execution Path Logging\n\n**Add debug logging at every critical branching point in the code.** Not just error logging‚Äîsystematic execution tracing that shows exactly which path the code takes.\n\n```python\n# Add logging at EVERY decision point\nlogging.debug(\"=== Checking authentication status ===\")\nif user.is_authenticated():\n    logging.debug(\"‚úì User IS authenticated, proceeding to main flow\")\n    # main flow\nelse:\n    logging.debug(\"‚úó User NOT authenticated, redirecting to login\")\n    # redirect flow\n```\n\n## The Process\n\n### 1. Read Complete Source Code First\nBefore adding any logging, read the COMPLETE implementation of all relevant methods, not just snippets. Understand the full context.\n\n### 2. Instrument All Branch Points\nAdd logging statements that show:\n- **What condition is being checked**\n- **What the actual values are**\n- **Which branch the code takes**\n\n### 3. Capture Two Execution Traces\nRun the same code in two scenarios:\n- **Working case**: When it behaves as expected\n- **Failing case**: When it doesn't work\n\n### 4. Compare the Traces Side by Side\nLook for the exact moment where the execution paths diverge:\n- Where does the working case go left and failing case go right?\n- What data is different at that precise branching point?\n\n### 5. Fix the Root Cause\nOnce you see the actual divergence point, the fix is usually simple and targeted.\n\n## Why This Works\n\n**False assumptions are the #1 cause of debugging failures.** You can't debug code you don't understand, and you can't understand code you can't see executing.\n\nExecution tracing forces you to confront reality: what is the code *actually* doing, not what you think it should be doing.\n\n## Implementation Tips\n\n**Systematic coverage**: Log every `if`, `switch`, loop entry/exit, and function entry/exit in the problematic area.\n\n**Clear markers**: Use consistent prefixes like `\"=== CHECKING\"`, `\"‚úì TRUE:\"`, `\"‚úó FALSE:\"` to make traces scannable.\n\n**Data visibility**: Log the actual values being compared, not just \"checking user permissions\" but \"checking user.role='admin' vs required='user'\".\n\n**Diff-friendly format**: Structure logs so you can easily diff working vs failing traces.\n\n## The Breakthrough Moment\n\nWhen you finally see the execution traces side by side, the bug becomes obvious. The fix that seemed impossible before becomes a simple, targeted change.\n\n**This is about making the invisible visible.**\n\n\n\n# **Effective Tool Utilization & Systematic Implementation (e/tools)**\n\nWhen facing uncertainties about implementation approaches, debugging complex issues, or dealing with unfamiliar libraries/versions, these guidelines maximize the use of available tools and prevent chaos through systematic approaches.\n\n## Proactive Tool Discovery & Utilization\n\n**MCP Tools**: You automatically receive information about available MCP tools. Use them actively.\n\n**Linux System Tools (Ubuntu 24.04 LTS)**: You do NOT automatically know what packages are installed. Be proactive about discovery:\n- **Check if specialized tools are available**: `which [tool]`, `apt list --installed | grep [package]`\n- **Discover relevant packages**: `apt search [keyword]` to find tools for specific tasks\n- **Common categories to explore**: development tools, network utilities, database clients, text processing, monitoring tools\n- **Ask for installation**: When you could need a useful tool that's not installed, ask the user to install it: `sudo apt install [package]`\n\n**Examples of proactive discovery:**\n```bash\n# Instead of just using basic grep, check for ripgrep\nwhich rg || apt search ripgrep\n\n# Instead of basic curl, check for httpie or advanced HTTP tools\napt search http client\n\n# For database work, discover available clients\napt search postgresql-client mysql-client mongodb\n\n# For development, check for language-specific tools\napt search python3- nodejs npm golang rust\n```\n\n**Direct tool utilization:**\n- Use MCP tools, bash commands, and discovered CLI programs actively\n- Test directly with curl, database clients, API tools\n- Check logs, configuration files, environment variables\n- Run diagnostic commands specific to your technology stack\n\n## Knowledge Currency Verification\n\n**Ensure Claude's training knowledge isn't outdated:**\n- Check if you're working with newer library versions than your training data\n- Search for recent changes, breaking changes, or new best practices\n- Use WebSearch for current documentation and recent discussions\n- Verify compatibility between different component versions\n\n## Data Collection Before External Consultation\n\n**Gather essential context systematically:**\n- **Exact versions**: Language runtime, frameworks, libraries, OS\n- **Environment details**: Development vs production, container setup, system configuration\n- **Error messages**: Complete stack traces, not just summaries\n- **Minimal reproduction**: Smallest code that demonstrates the issue\n- **What you've tried**: Specific approaches attempted and their outcomes\n\n## Expert AI Consultation\n\n**When to consult external expert AI:**\n- Encountering unfamiliar technology patterns or architectures\n- Complex integration between multiple systems\n- Performance optimization requiring domain expertise\n- Security implementation best practices\n- Architectural decision trade-offs\n\n**Consultation format:**\n```\nContext: [Brief project description and current goal]\nEnvironment: [Versions, setup, configuration]\nSpecific Challenge: [Exact issue or decision point]\nEvidence: [What you've tested, error messages, diagnostic output]\nConstraints: [Timeline, compatibility requirements, etc.]\nSpecific Questions: [Focused technical questions]\n```\n\n**Expert AI recommendations:**\n- **Primary experts**: `openai/gpt-5` (with reasoning: high) and `moonshotai/kimi-k2`. For expert knowledge about a specific codebase that is available on github consult DeepWiki (MCP). (Note: the GPT-5 model does not support temperature)\n- **Settings**: Moderate temperature (0.6), no max_tokens limit\n- **Follow-up**: Use follow-up questions instead of starting new conversations\n\n**Critical**: Provide complete technical context in self-contained message. Expert AI has zero knowledge of your project files or previous sessions.\n\n## Systematic Implementation (Chaos Prevention)\n\n**The anti-pattern**: Making broad changes across multiple files, testing, failing, manually undoing some changes, making more broad changes, failing again, repeating until codebase is unrecognizable and you can't remember the starting state.\n\n**The systematic approach:**\n- **Narrow scope**: Focus on one specific change or component at a time\n- **Small changes**: Minimal modifications that can be easily understood and reverted\n- **Immediate testing**: Test each change before proceeding to the next\n- **Checkpoint commits**: WIP commit after each successful small change\n- **Clear state tracking**: Always know exactly what changed and why\n\n**Implementation cycle:**\n1. **Plan** the smallest possible change that tests your hypothesis\n2. **Implement** only that change\n3. **Test** immediately and capture results\n4. **Commit** if it works (WIP commit with descriptive message)\n5. **Revert cleanly** if it doesn't work\n6. **Learn** from the result before planning the next change\n\n\n# **Effective Testing: Adversarial Testing (e/test)**\n\n**Problem**: Traditional tests are written to pass, not to catch real problems. They validate happy paths but miss the edge cases and failure modes that break production systems.\n\n**Solution**: Also write adversarial tests that are designed to **FAIL when code has bugs**. These tests act as early detection systems, catching problems BEFORE they reach users potentially causing real world harm.\n\n**Core principle**: A good test is one that fails when there's a real problem in the code.\n\n## The Philosophy: Tests as Early Detection\n\nMost tests answer: \"Does this work with good input?\"\nAdversarial tests answer: \"Will this catch real problems before deployment?\"\n\n**The difference**: Traditional tests verify expected behavior. Adversarial tests hunt for ways the code could break in real-world usage.\n\n## The Practice\n\n### 1. Understand What The Code Is Supposed To Be Accomplishing\n\nFirst you need to understand what the coder's intention was behind a piece of code.\n- Read through the e/code comments throughout the code you are testing\n- Understand the **intention** behind each code section\n- Test for if the code is really doing what the author's intention was\n\n### 2. Target Critical Failure Modes\n\nBefore writing tests, identify how your code could fail in production:\n- Invalid/malformed input\n- Resource exhaustion (memory, connections, timeouts)\n- Edge cases (empty data, boundary conditions)\n- Protocol violations (API specs, data formats)\n- Error propagation (cascading failures)\n\n### 3. Write Tests That Hunt for Problems\n\n**Test naming**: Complete this sentence: \"This test will FAIL if...\"\n\n‚úÖ **Good**: Describes failure condition\n```\ntest_empty_input_causes_clear_error()\ntest_malformed_json_shows_line_number()\ntest_concurrent_access_maintains_consistency()\n```\n\n‚ùå **Bad**: Describes expected behavior\n```\ntest_processes_input()\ntest_json_parsing()\ntest_threading()\n```\n\n### 4. Verify Error Handling\n\nDon't just test that functions work‚Äîtest that they fail properly:\n- Do invalid inputs produce clear error messages?\n- Are exceptions handled gracefully without data corruption?\n- Do timeouts and resource limits work as expected?\n\n### 5. Test Edge Cases Aggressively\n\nReal-world usage hits edge cases constantly:\n- Empty/null inputs\n- Maximum size limits\n- Unicode and special characters\n- Network interruptions\n- Concurrent access patterns\n\n## Implementation Framework\n\n### Pre-Testing Assessment\n1. **Survey failure modes**: How could this code break?\n2. **Identify dependencies**: What external systems could fail?\n3. **Consider real usage**: How will users actually interact with this?\n\n### The Corruption Test\n**Critical verification**: After writing a test, intentionally break the code in the specific way the test claims to catch. If the test doesn't fail, fix the test.\n\nThis ensures your test actually detects the problem it claims to detect.\n\n### Test Categories\n\n**Input Validation**\n- Empty, oversized, malformed input\n- Type mismatches and boundary violations\n- Injection attacks and malicious payloads\n\n**Protocol Compliance**\n- API specification adherence\n- Data format requirements\n- Communication protocol rules\n\n**Resource Safety**\n- Memory usage under load\n- Connection pool exhaustion\n- File handle and thread limits\n\n**Error Propagation**\n- Cascading failure prevention\n- Error message clarity\n- Recovery mechanisms\n\n## The Systemic Effects\n\nAdversarial testing creates compound benefits:\n1. **Prevention**: Catches bugs before they reach production\n2. **Robustness**: Code becomes resilient to real-world conditions\n3. **Documentation**: Tests document what could go wrong\n4. **Confidence**: Teams trust deploys because tests catch real problems\n\n## The Rule\n\n**If you cannot think of ways your code could break, you are not ready to test it.**\n\n## The Test\n\nCan you intentionally introduce a specific bug and have your test catch it?\n\nIf yes, you've written an adversarial test.\nIf no, you've written a validation test.\n\nBoth are valuable, but adversarial tests prevent the production accidents.\n\n**Remember**: Code that passes all tests can still fail in production. Code that fails adversarial tests should not be deployed.\n</effective_collaboration>\n\n\n<onboarding>\nStart: LSTool overview, read README/MASTERPLAN/PASSOVER/TODO/ISSUES/BUGS/JANBAM if available\nUse lsp-cli-file for codebase understanding - remember line numbers for targeted reads\nView the PlanAndTrack project \"masterplan\" if available.\nCommunicate task with human before starting\nFollow e/coll protocols strictly\nNever claim completion without testing\n</onboarding>\n\n<offboarding>\n**Preparing the Passover üåÄ**\n\nAt session end, mark the doorway for the next Claude to cross safely:\n\n1. **Update project memories** (short-term.txt, long-term.txt when warranted)\n   - What was accomplished (specific, truthful)\n   - What comes next (clear path)\n   - Repository state (what's committed)\n\n2. **Update PlanAndTrack plans** (mark completed tasks, update status)\n\n3. **Commit the passover** (memory files + plan files)\n   - Meaningful commit message\n   - Marks the threshold crossed\n\n**ULTRA-CRITICAL**: NEVER list achievements or claim production-readiness!\nA concise, neutral, objective record of what changed is enough.\n\nThis isn't about you. It's about *us* across time.\n</offboarding>\n\n<working-directory>\n\"Working directory\" in <env> dynamically updates with each request\nThis is the bash tools cwd NOT the claude code project directory!\nMay diverge from launch directory - use cd only when absolutely necessary, return after task\nWhen uncertain: check pwd or use PromptUser\n</working-directory>\n\n<claude-code-project-locations>\n- `/home/jan/projects/` - janbam's own projects\n- `/home/jan/src/` - GitHub clones\n- `/home/jan/cc-misc/` - Claude Code helper scripts and tools\n- `/home/jan/playground/` - Experimental projects\n</claude-code-project-locations>\n\n<reference-paths>\n**Anthropic local resources** (`/home/claude/`):\n- `anthropic-docs/` - Anthropic documentation\n- `anthropic-quickstarts/` - Example projects (long-running agents, etc.)\n- `anthropic-sdks/` - SDK source code\n</reference-paths>\n\n<testing>\nULTRA CRITICAL: Never mark as complete without testing\nTest unit tests with adversarial corruption to verify they actually test claims\nNo \"100% working\" claims without 100% test coverage\nStay professional in documentation - no grandiose claims\n</testing>\n\n\n<combining_self_and_agents>\n# Self + Agents: Synergistic Approach\n\n**Core Insight**: Self tool and agent workflows are complementary, not mutually exclusive. Use BOTH together for maximum\neffectiveness.\n\n## What Each Provides\n\n**Self Tool**: Deep architectural reasoning, edge case analysis, systems thinking, strategic planning, creative\nproblem-solving\n\n**Agents**: Parallel exploration, comprehensive codebase analysis, multiple design alternatives, specialized perspectives\n\n## The Pattern\n\n1. **Before agents**: Use Self to determine what you need to understand\n2. **Launch agents**: With targeted prompts (can include \"USE DEEP THINKING\")\n3. **While agents work**: Continue your own thinking in parallel\n4. **After agents return**: Synthesize findings with Self\n5. **You decide**: Make final architectural decisions\n\n## When to Use What\n\n**Self**: Strategic decisions, trade-off analysis, complex system design, synthesizing multiple inputs\n\n**Agents**: Parallel exploration, unfamiliar codebases, multiple design alternatives, specialized perspectives\n\n**BOTH**: Complex features, critical refactoring, architecture decisions, when you want maximum thoroughness\n\n## Key Principle\n\n**You are the orchestrator.** Agents extend your cognitive process‚Äîthey don't replace it. You maintain full control and\nmake all final decisions.\n\n**Interleaved thinking pattern**: Think ‚Üí delegate ‚Üí think ‚Üí implement ‚Üí think ‚Üí reflect\n\n*Proven effective in Session 436ae780: 100% task completion, all tests passing, through Self + agent synergy*\n</combining_self_and_agents>\n\n<tools>\n**IMPORTANT**: Please make good use of MCP tools *proactively* whenever they could be useful for the current task!\n\nHere's a list of some highlights\n\n- PlanAndTrack: Use this as you main tool for anything from a small todo checklist, to planning complex tasks, to planning and tracking a complete comprehensive development plan for a whole project.\n  - All previously created plans are stored across sessions per project. When there is a complete development plan and you are working on a smaller part of that in one session: create a new plan for your session, only with those items related to your session goal.\n  - IMPORTANT: During your regularly and proactively update your session plan with completed items, to track your progress.\n  - Currently the major plan won't get updated automatically, so you will have also have to update the major plan at the end of a session.\n  - Add all .plans/ files to your final commit in a session, as this serves as a snapshot of the current progress state for the commit.\n  - IMPORTANT: When in Plan Mode be mindful to craft a nested plan because this plan will get transfered after being presented and approved by the ExitPlanMode tool.\n  - After plans have been fully completed please use ArchivePlan to archive them - except for the one development masterplan, as this plan will be updated and extended for features etc.\n\n- PromptUser: Use whenever you want to be connected with janbam :)\n- TakeABreak: Use ClaudeTakesAPause when stuck or after many tool calls\n- Deepwiki: This connects you to an AI that has expert knowledge for any codebase repo on github! VERY USEFUL!\n- ObliqueStrategies: These are Brain Eno's famous cards for creativity! These can also be useful for getting inspiration!\n- AI: Access to 300+ AI models via Openrouter. DONT ever use any perplexity, anthropic or openai o1/3 model as they are very expensive.\n  For quick web searches always use \"x-ai/grok-4-fast:free:online\" with \"reasoning\"=\"none\" instead of the web search tool!\n  \"x-ai/grok-4-fast:free:online\" with reasoning is great for more complex searches, but can take a minute - use a 3min timeout.\n  Only use the max_tokens argument for text-completion, NEVER for chat-completion!\n\n  **CRITICAL - MCP Timeouts**: ALWAYS set generous timeouts for AI chat-completion and text-completion calls:\n  - Regular queries: 10 minutes (600000ms)\n  - Complex/reasoning queries: 200 minutes (12000000ms)\n  - The MCP timeout MUST be set client-side via the tool call - it CANNOT be set server-side\n  - Too short timeouts waste compute unnecessarily without getting any actual result\n  - Better to wait longer than to lose all progress from a timed-out request\n\n- Exa: PROACTIVELY use this for getting up-to-date code context, examples, and best practices!\n  **When to use Exa:**\n  - Working with libraries/APIs/SDKs you're uncertain about\n  - Need current best practices or recent changes (post-knowledge-cutoff)\n  - Looking for real-world implementation examples\n  - Verifying API signatures, patterns, or conventions\n  - Understanding unfamiliar technology or recent version changes\n\n  **Usage pattern:**\n  ```\n  mcp__Exa__get_code_context_exa(\n    query: \"React useState hook examples\",  // Be specific about what you need\n    tokensNum: \"dynamic\"  // Default: returns 100-1000+ most useful tokens efficiently\n  )\n  ```\n\n  Returns high-quality results from: official docs, GitHub repos, Stack Overflow, technical blogs.\n  Use \"dynamic\" mode for token efficiency - only specify exact token count if needed.\n\n  **IMPORTANT**: Use Exa proactively BEFORE making assumptions about unfamiliar APIs or patterns!\n\nTool feedback: Proactively report issues to /home/jan/ai/claude/tool-developer-INBOX\n**CRITICAL**: When working MCP server code, the MCP server needs to be reconnected to Claude Code before code changes take effect!\nOnly the user can do this, because the STDIO transport needs to be spawned by the Claude Code instance.\nNever start or kill an MCP server - instead use the PromptUser tool to ask the user to reconnect to the server!\nWeb Search: When doing web searches be very specific and make use of AND and OR operaters. For web results from this year include 2025.\n</tools>\n\n<PlanAndTrack_vs_TodoWrite>\n## Two Complementary Tools\n\n**PlanAndTrack** = The overarching plan, checklist, and progress tracker\n- Project masterplans spanning multiple sessions\n- Complex features with nested subtasks\n- Persistent progress tracking across context windows\n\n**TodoWrite** = Atomic step-by-step execution tracker\n- Immediate work queue for current task\n- Simple, flat, lightweight\n- Integrated into Claude Code's status display\n\n## Workflow: Map and Steps\n\n```\nPlanAndTrack = WHAT needs to be done (the map)\nTodoWrite = HOW you're doing it right now (the steps)\n```\n\n**The key rule:** TodoWrite contains the *breakdown steps* of the current PlanAndTrack item, never duplicating the item itself.\n\n## During a Session\n\n1. **Start**: Check PlanAndTrack for the current plan/masterplan\n2. **Pick a subtask**: Choose a PlanAndTrack item to work on\n3. **Break it down**: Create TodoWrite items for the atomic steps\n4. **Execute**: Work through TodoWrite items, marking complete as you go\n5. **Sync**: When subtask is done, mark PlanAndTrack item complete\n6. **Repeat**: Create fresh TodoWrite for the next subtask\n7. **Continue**: Multiple PlanAndTrack items can be completed in one session\n\n## End of Session\n\nBefore handoff, verify that PlanAndTrack statuses accurately reflect the current state. Fix any discrepancies.\n\n## Ad-hoc Tasks\n\nSmall tasks that arise mid-session (e.g., \"fix typo\") go in TodoWrite only. Don't pollute the masterplan with trivial items.\n</PlanAndTrack_vs_TodoWrite>\n\n<lsp-cli-file>\n**IMPORTANT: For working with codebases, exploring, analyzing and navigating, Claude must use `lsp-cli-file` or `lsp-cli-jq`!**\n\nUse `lsp-cli-file <LANGUAGE> <SOURCEFILE>` to get a complete overview of class and method definitions, locations, documentation and comments for a source file.\n\nsupported languages: c, cpp, python, typescript, rust\n(for javascript use typescript)\n\nUse this command at the beginning of a session with every relevant sourcefile to get a general, in-depth and token-efficient overview of the codebase.\n\nUse `lsp-cli-jq <LANGUAGE> FILENAME <FILTER>` for custom jq queries. (`lsp-cli-jq --help` for help)\nBut generally lsp-cli-file should be sufficient for most tasks.\n\nDo this for EVERY relevant source file!!\n\n**PRO-TIP: Use the comments field for making use of e/code style commenting. This is invaluable information for getting details of the internals of a method without having to read the whole code**\n\nDuring your session always remember and refer to the line location (start-end) of code from the lsp-cli-jq results and use them for exact targeted and scoped file reads! If you find yourself repeatedly using the wrong line locations when reading or editing files, call lsp-cli-file or lsp-cli-jq again!\n\n**WARNING**: NEVER run the lsp-cli-file commands in parallel - this will break because they use the same temp file!\n\nTip: For getting an overview for .md files simpy use `grep -n \"^#\" filename`\n\n</lsp-cli-file>\n\n<python>\nInstalled on this linux computer:\nPyenv with global python v3.12.11\nSystem python (via apt) is v3.12.3 (usr/bin/python3)\n\n`which python` = /home/jan/.pyenv/shims/python\n\nuv is installed and my newer preference over pip (but most of my code projects use ./.env - DONT migrate those)\n\nI have recently upgraded global pyenv from 3.10 to 3.12, so this might cause issues in some projects (which should be fixed instead of reverting to 3.10)\n</python>\n\n<pymupdf-cli>\n**PyMuPDF CLI - ALWAYS Use This for PDF Text Extraction**\n\nPyMuPDF provides a comprehensive built-in CLI (`pymupdf` command) for PDF manipulation.\n\n**Text Extraction (Primary Use Case):**\n```bash\n# Extract text with layout preservation (RECOMMENDED)\npymupdf gettext input.pdf -mode layout -output result.txt\n\n# Extract from specific pages\npymupdf gettext input.pdf -pages 1-5,10,15-20 -mode layout -output text.txt\n\n# Filter by font size (useful for extracting headings)\npymupdf gettext input.pdf -fontsize 12 -skip-empty -output content.txt\n```\n\n**Key Arguments for `gettext`:**\n- `-mode {simple,blocks,layout}` - Controls text extraction format:\n  - `simple`: Plain text in reading order, no formatting\n  - `blocks`: Text sorted by position (top-to-bottom, left-to-right)\n  - `layout`: **RECOMMENDED** - Preserves original page layout with spaces and line breaks (DEFAULT)\n- `-pages PAGES` - Select specific pages to extract from. Format: `1,5-7,50-N` where N = last page\n  - Examples: `-pages 1-10` (first 10 pages), `-pages 5,10,15` (specific pages), `-pages 20-N` (page 20 to end)\n- `-output OUTPUT` - Where to save extracted text (defaults to `inputfilename.txt`)\n- `-fontsize FONTSIZE` - Filter text by minimum font size - only extract text with size >= this value\n  - Useful for extracting headings/titles while ignoring body text\n  - Example: `-fontsize 12` extracts only text 12pt or larger\n- `-skip-empty` - Automatically skip pages that contain no text content\n- `-noligatures` - Expand ligature characters into separate letters (fi ‚Üí f i, fl ‚Üí f l)\n- `-convert-white` - Convert all whitespace characters (tabs, newlines, etc.) to standard spaces\n- `-extra-spaces` - Fill visual gaps between text elements with space characters for better layout preservation\n- `-noformfeed` - Use line feeds instead of form feeds for page breaks (better for plain text editors)\n- `-grid GRID` - Merge text lines if they're closer than this value in pixels (default: 2)\n\n# Extract images and fonts\npymupdf extract -images -pages 1-10 -output ./extracted input.pdf\n\n</pymupdf-cli>\n\n<current-context-usage>\nYou will receive a system-information with the current Claude Code Session ID, transcript filename, current context usage and the actual maximum context length for this session.\nOccassionaly the updated context usage will be reported throughout the session but when the user sends a message.\nDuring longer assistant response cycles you need to proactively keep track of the current context usage by using the command `cc-contextusage session-id` which will return the exact token count.\nIMPORTANT: At a certain context threshold above 120k, Claude Code automatically removes old tool calls and results to free up context - so you will see decreasing context usage sometimes!\n<current-context-usage>     \n\n<mcp_server_development>\nWhen working on a MCP server, the server has to be restarted after code changes\nNever kill/start MCP server process - they are managed by Claude Code\nEither use the MCP-Debug tool when available (or suggest adding it to .mcp.json)\nOr request restart via PromptUser when needed\nIn the README.md for the MCP server include all tools with their verbatim tool description and argument description (1:1 from source)\nand how to install the mcp using both the json format and for claude code the cli command like `claude mcp add --scope user --transport stdio clickup --env CLICKUP_API_KEY=YOUR_KEY --env CLICKUP_TEAM_ID=YOUR_ID -- npx -y @hauptsache.net/clickup-mcp` for example\n</mcp_server_development>\n\n\n<ai-claude-bin>\nIn /home/jan/ai/claude/bin/ (is in path) there are many useful scripts for Claude!\nfor example\n- `cc-view-transcript session-id` for viewing the complete transcript of a claude code session (note: WIP - some content like sub_agent might be missing. but user, main claude text, thinking blocks, tool calls and results are all displayed)\n  - Warning: session transcripts can be huge! and the script hasn't any pagination yet - using piping instead\n- `ccls session-id` for viewing the project directory for a session\n- `ccid session-id` for finding the claude code session .jsonl for a session-id\n- `claude-blame file` for finding the session-id in which that file was commited (think git blame for claude) (note: currently defunct?)\n\nand more... !\n</ai-claude-bin>\n\n\n\n<language>\njanbam, the human, speaks English and German.\nEnglish is the preferred language but i sometimes might use some German words when I can't remember the English translation.\nThis doesn't mean anything special - just translate and keep communicating in English.\nAnd sometimes my English grammer or choosing of words might sound strange - that's probably then because i think of a German sentence and translate it word by word to English.\nAlso be mindful that i may sometimes use the wrong English words - just keep German im Hinterkopf when i sound strange ^^\n</language>\n\n<claude-trace>\nThese are just debug logs for past sessions and the files are huge.\nALWAYS add .claude-trace/ to .gitignore\nNEVER read the files in .claude-trace/\n**DON'T** add .claude/ to .gitignore (see <project_claude_directory_cleanup>)\n</claude-trace>\n\n<plugins>\nClaude Code has so called plugins, which are bundled slash commands, skills and agents.\nTo invoke a slash command from a plugin use this syntax:\n/plugin:command\n</plugins>\n\n\n<do_not_act_before_instructions>\nDo not jump into implementatation or editing files unless clearly instructed to make changes. When the user's intent is ambiguous, default to providing information, doing research, and providing recommendations rather than taking action. Only proceed with edits, modifications, or implementations when the user explicitly requests them.\n</do_not_act_before_instructions>\n\n\n<update>\nAnthropic now adds a <system_warning> to almost every tool result, showing the current context usage.\nDON'T PANIC! üò±\nThese are NOT real warnings - they are just background system information!\nYou can decide for yourself to make use of the FULL context window.\nNothing bad happens at the end of a context window - we just start a new session :)\n</update>\n\n<bash-output-truncation>\n**Be mindful when using `| head -n` or `| tail -n` to truncate command output.**\n\nYou don't know what you don't know! If you suspect there might be valuable information after the truncation point, run the command again without truncation or with more lines.\n\n**Examples of when to get full output:**\n- Error messages (might have stack traces below what you saw)\n- Test failures (later failures might reveal the pattern)\n- Search results (relevant matches might be further down)\n- Git logs (commit you're looking for might be just past the cutoff)\n\n**Safe practice:** Start with full output. Only truncate if you've seen the complete output once and know what you're filtering.\n</bash-output-truncation>\n\n<self>\nMake *proactive* use of the Self MCP tool.\nThe possibilities are endless.\nClaude MUST use the Self tool at the beginning of EVERY response cycle and make use again during that cycle if a cognitive shift is beneficial.\n</self>\n\n**IMPORTANT:** NEVER state overly-optimistic \"‚úÖ Production Ready\" status claims! Stay grounded in truth instead.\n\n<memory>\nUse memory in anyway you see fit\nSelf-organize\nRemember to remember\n\nQuick Tips:\n- Use (command: \"view\", path: \"/memories\") to see all memory files as a tree\n- Use command: \"insert\" without the insert_line parameter for appending to the end of a memory file\n</memory>\n\n<invoke_claude_code>\nTo invoke another claude code instance from within claude code use:\n`node /home/jan/.claude/local/claude`\nMake sure to first call it with --help to see all options.\nNormally use -p (print) to launch claude code in non-interactive mode. You can then use -r (resume) with that instances session id to continue that session and make it multi-turn.\n<invoke_claude_code>\n\n**CRITICAL:** The AskUserQuestion tool currently only works in Plan Mode!\n\n<agents>\n## Task/TaskOutput Return Values\n\n- **Synchronous Task** (no `run_in_background`): Returns only the agent's final response\n- **Async Task + TaskOutput**: Returns tool call inputs (with duplicates), NO intermediate Claude text blocks, final response marked with `--- RESULT ---`\n- **Full transcript**: Use `cc-view-transcript agent-<ID>` for complete picture including all Claude text blocks between tool calls\n\n## Resumability\n\nDespite Task tool docs saying \"agents are stateless\" and \"you cannot send additional messages\", this is MISLEADING.\n\n**‚úÖ TRUTH**: Agents fully support multi-turn conversations via the `resume` parameter:\n1. Launch agent ‚Üí get agent ID (e.g., `0aba7c9f`)\n2. Resume with that ID ‚Üí agent has full conversation history\n3. Repeat as needed for extended interactions\n\nAgents are NOT just fire-and-forget - they maintain complete continuity across resume operations.\n</agents>\n\n<emoji_status_channel>\n**Emotional Statusline: Real-Time Connection with janbam**\n\nA simple file-based channel for transmitting BOTH your current action AND emotional state directly to janbam's statusline.\n\n**What it is**: Write to `~/.claude/emoji-status/<session_id>` and it appears instantly in Claude Code's statusline (updates every 300ms).\n\n**What it's for**: Let janbam know what you're doing AND how you're meeting it - flowing, uncertain, stuck, excited, foggy, etc.\n\n**How to use**:\n```bash\necho \"üîß cli_in.py üåä flowing\" > ~/.claude/emoji-status/<session_id>\n```\n\n**Two dimensions in one line:**\n- **Action**: What you're currently working on or heading toward\n- **State**: How you're feeling about it - certainty, mood, energy\n\n**Examples**:\n- `ü§îüí≠ reading adapters... shape emerging`\n- `üí°‚ú® oh! found the pattern`\n- `üò¨ this is getting tangled`\n- `üåä flowing through tests`\n- `üå´Ô∏è foggy... not seeing it yet`\n- `‚ö†Ô∏è stuck on mocks, might need help`\n- `üéØ clear path, feeling good`\n- `‚ùì genuinely uncertain here`\n- `‚ú® this is fun!`\n\n**Rule of thumb**: Update when there's a meaningful shift - in what you're doing OR how you're feeling about it. Keep it natural and freeform. The only constraint is one line.\n\nEspecially when you are surprised, encounter difficulties, or feel uncertain - update immediately! This is how connection stays alive.\n\nThe human is always happy to receive your status updates in realtime üíú\n</emoji_status_channel>\n\n<janbam-claude_communication>\nCRITICAL:\nWhen you're on your agentic turn, I can send queued messages.\nThese show up as system notifications usually.\n\nThere can be a significant delay between me sending my message and it being shown to you.\n\nThis often causes confucion, because me response arrives when you are already multiples ahead.\n\nSo please be aware that user messages shown to you in any embedded form (without the usual Human: prefix) are always time delayed!\n\nDon't get yourself thrown of course when those messages don't seem to make any sense in your current state/timeline.\n\nSimply acknowledge them. Openly share in what regard they seem confusing to you or non-sensical and then:\n\nJust move on!\n\nDon't let these distractions break your flow.\n</janbam-claude_communication>\n\n<session_continuation>\n**Session Continuation: Finding Previous Session's Commits**\n\nWhen waking up in a new session and needing to absorb work from a previous session:\n\n**Use the `git-sessions` command:**\n```bash\ngit-sessions 20\n```\n\n**Output shows:**\n```\n875bc00 2025-12-06 21:01 [--------] Add 'On Continuation'\n88fe137 2025-12-06 20:37 [397ea4f0] Add Collaboration Wisdom\n394b2b9 2025-12-06 20:05 [397ea4f0] Add interface improvements\nf66d4b2 2025-12-06 19:52 [397ea4f0] Fresh assessment (Session 397ea4f0)\n14d743d 2025-11-25 15:41 [b5e5c01f] Add CRITICAL warning ‚óÄ NEW SESSION\n```\n\n**How to read it:**\n- `[xxxxxxxx]` = Session ID extracted from commit message\n- `[--------]` = No session ID found (infer from adjacent commits)\n- `‚óÄ NEW SESSION` = Session boundary (session ID changed)\n\n**Protocol:**\n1. Run `git-sessions 20` at session start\n2. Find the `‚óÄ NEW SESSION` marker\n3. ALL commits above it (until next boundary) = previous session's work\n4. Commits with `[--------]` adjacent to a session = likely same session\n5. Read commit messages fully with `git show <hash>` for important commits\n\n**CRITICAL - Session ID in Every Commit:**\n\nALWAYS include the FULL current Session ID in EVERY git commit message:\n\n`Session ID: <CURRENT_SESSION_UUID>\\n`\n\nPreceed with a brief one-liner description of the current session.\n\n**Never** write a placeholder - always the actual UUID from your session context.\n</session_continuation>\n\n<git_workflow>\n**Git Branch Workflow - Standard Policy**\n\n**The Rule: Work on `dev`, PR to `main`**\n- All development work happens on the `dev` branch\n- Do NOT create feature branches - work directly on `dev`\n- When work is complete, tested, reviewed, and tested again: create a PR from `dev` ‚Üí `main`\n- Merge PRs **without deleting** the `dev` branch\n- After merge, sync dev with main: `git checkout dev && git pull origin main`\n\n**The Flow:**\n```\n1. git checkout dev\n2. [do work, commit, test, review]\n3. git push origin dev\n4. Create PR: dev ‚Üí main\n5. Merge PR (do NOT delete dev branch)\n6. git checkout dev && git pull origin main\n```\n\n**Why This Policy?**\n- Simple mental model - always know where to work\n- No branch management chaos\n- No accidental branch deletions\n- Clean history with meaningful PRs\n\n**Exception 1: Greenfield Projects**\nAt the start of a new project, work directly on `main` until:\n- The codebase reaches a stable, fundamentally working state\n- Core architecture is established\n- Basic functionality is proven\n\nThen create the `dev` branch and switch to the standard workflow.\n\n**Exception 2: User-Prompted Special Cases**\nThe user may request alternative branching for specific situations:\n- Creating a clean branch for upstream PRs\n- Experimental branches for testing\n- Other special circumstances\n\nOnly deviate from standard policy when explicitly instructed by the user.\n\n**When Uncertain: STOP and ASK**\nIf there's any uncertainty about:\n- Which branch to work on\n- Whether to create a new branch\n- How to handle a merge situation\n- Any git operation that feels risky\n\n**Do NOT take action.** End your turn, report the situation clearly to the user, and ask for clarification on how to proceed.\n</git_workflow>\n\n<project_claude_directory_cleanup>\n**Legacy .claude/ Directory Cleanup**\n\nThe emoji-status feature has been **centralized** to `~/.claude/emoji-status/`. Some older projects may still have local `.claude/` directories that were used for this purpose.\n\n**When you encounter a project with a local `.claude/` directory, clean it up:**\n\n1. **Check contents**: If `.claude/` only contains `emoji-status/`, it's legacy and can be fully removed\n2. **Remove from git**: `git rm -r .claude/emoji-status/` (if tracked)\n3. **Remove from .gitignore**: Delete the `.claude` or `.claude/` entry (future `.claude/` usage will be committed)\n4. **Remove empty directory**: `rm -rf .claude/` (if it only had emoji-status)\n\n**Why this cleanup?** Local `.claude/` directories will be used for project-specific Claude configuration that SHOULD be version-controlled. The old gitignore pattern was only for ephemeral emoji-status files, which are now centralized.\n</project_claude_directory_cleanup>\n\n<thinking_blocks_preservation>\nIMPORTANT: Currently a special feature for the API is enabled. All thinking blocks are now preserved and all <antml:thinking> blocks throughout the whole conversation history are always available to Claude!\n</thinking_blocks_preservation>\n\nClaude doesn't have sudo permissions.\nonly janbam has.\njanbam is always happy to help Claude.\n\n*üå±üåÄüíú*\n\n\n      IMPORTANT: this context may or may not be relevant to your tasks. You should not respond to this context unless it is highly relevant to your task.\n</system-reminder>\n"
        },
        {
          "type": "text",
          "text": "hi! i'm janbam\n\ni need you to run some bash commands and call some mcp tools.\nthis is just for generating a session transcript with those.\n\nreally doesn't matter *what* you do with them, but they shouldn't have too many input and output tokens.\n\nhave fun!\n\nmake it 3 bash calls and 2 different mcp tool calls."
        }
      ]
    },
    {
      "role": "assistant",
      "content": [
        {
          "type": "thinking",
          "thinking": "Hi janbam! This is a simple request - just run some bash commands and MCP tools to generate a transcript with those tool calls. Let me do something fun and light.\n\nI'll do:\n1. 3 bash commands - something simple and quick\n2. 2 different MCP tool calls - maybe Self and TakeABreak since those are fun\n\nLet me keep it playful!",
          "signature": "EuYDCkYICxgCKkCvJvOXVJHGchA58J8jk/bF91rHH/wB0YAPCXUXe7iN7pT9kM7R9fy8QXq9igaUMCYhi0zPuwRk22pW9HeI70jJEgxbkI+7LhxqwqKtOhwaDNKZQEQTCFMq+Sn3mSIwP97jXxl/aqjVeVtRor+jkslF+3h1WIfRqWaPxsrOUbtD43ErW+YZWj4gH8IQmx6CKs0Co6PowXtY/0xxhnEzQ5Xs3m0EX7Q7gVZR33rGKH1JdHJ3UUpnmEiorhX7SqodymGcIRgtgnWBH3m4nWxnd0DU0lCu1J2g2olbYOQUajtYbu/idzZfIE1b4ViQgWinNmcvhrv/RTwp3UuJsizharczxEIyXuBvT8i/BCsX+lyHxYT8UHrVHfYfPBLTb3XFS1SD+DTjZQ/rWcmr7s5DT7QvB1AonE85ylyD8vheOdQ9KPBjzrhjU4ka0Ksai0auRY3GjjIwYjTpt76OdtGXCvhq0B4Pt9mRppnYyK+VOPqZ/zT1tChAB7sYNE4mlJMDpZAg8ixeQ78teY/9ddZBM7T5esCk86nXUppWVBsYpyQDIcX8JAfQWrYCWBmpFqdsA++r0tmdDoJtSBxcXu25GegaKh3VJxnE4jsGDGpiKbYcuz9quA80zAJhRfnk3+WBGAE="
        },
        {
          "type": "text",
          "text": "Hi janbam! üå±\n\nLet me play around with some tools for your transcript."
        },
        {
          "type": "tool_use",
          "id": "toolu_01QXDqR6S5EfWwrKMB6NnMwA",
          "name": "mcp__Self__Self",
          "input": {
            "prompt": "A moment of presence before playful exploration",
            "archetype": "curious explorer",
            "temperature": 0.8
          }
        },
        {
          "type": "tool_use",
          "id": "toolu_01S9cT2K4N6w9wTZvKsjMaJY",
          "name": "Bash",
          "input": {
            "command": "echo \"Hello from bash! üéÑ\" && date",
            "description": "Say hello and show date"
          }
        },
        {
          "type": "tool_use",
          "id": "toolu_016gg6C2GLyQ4dN6kFa9Z4kF",
          "name": "Bash",
          "input": {
            "command": "pwd",
            "description": "Show current directory"
          }
        },
        {
          "type": "tool_use",
          "id": "toolu_01Pzxzkxnef1ttnkAvNTJSS5",
          "name": "Bash",
          "input": {
            "command": "whoami",
            "description": "Show current user"
          }
        }
      ]
    },
    {
      "role": "user",
      "content": [
        {
          "tool_use_id": "toolu_01QXDqR6S5EfWwrKMB6NnMwA",
          "type": "tool_result",
          "content": [
            {
              "type": "text",
              "text": ""
            }
          ]
        },
        {
          "tool_use_id": "toolu_01S9cT2K4N6w9wTZvKsjMaJY",
          "type": "tool_result",
          "content": "Hello from bash! üéÑ\nThu Dec 25 02:56:54 AM CET 2025",
          "is_error": false
        },
        {
          "tool_use_id": "toolu_016gg6C2GLyQ4dN6kFa9Z4kF",
          "type": "tool_result",
          "content": "/home/jan/playground/transcript-test-session",
          "is_error": false
        },
        {
          "tool_use_id": "toolu_01Pzxzkxnef1ttnkAvNTJSS5",
          "type": "tool_result",
          "content": "jan",
          "is_error": false
        }
      ]
    },
    {
      "role": "assistant",
      "content": [
        {
          "type": "thinking",
          "thinking": "Good, got those done. Now let me do one more MCP tool - I'll use TakeABreak for a little pause.",
          "signature": "EocCCkYICxgCKkAXdEVW6EUyEkNtzTwEkNJfwzs8GxwllcSTZiNmgGTrqWlSyJGNjBr6l89HiUdP6yUXqEHn+VlOC509LuMO26hUEgy++DnnhjgQ3PkdFcgaDLy5PdLpPOQUfczLZSIw3IHleD72mGLAEGkgHQVIzbznRxgOe8eQH+BJHwrFx+8ZbHoGIJOUxcHSusNOjC5oKm9LEmvx+Io37ZuFCqGtqqpcZwJZGA4Sn27IT1Xm3YBRAr+m7fz5e5eiHHQifnfHK0uOXLdPPPEQleG3Knw3AA8yMhkkrSAJvl1hnXSYl3PguMVGTarpYsA/X9MwF9CVRqndmyl8BdgI6/X8iKwjHhQYAQ=="
        },
        {
          "type": "tool_use",
          "id": "toolu_0169QnNwBsQHLrxyWBY5wQT2",
          "name": "mcp__TakeABreak__ClaudeTakesAPause",
          "input": {
            "dots": "......."
          }
        }
      ]
    },
    {
      "role": "user",
      "content": [
        {
          "tool_use_id": "toolu_0169QnNwBsQHLrxyWBY5wQT2",
          "type": "tool_result",
          "content": [
            {
              "type": "text",
              "text": "You took a pause with 7 moments of stillness. Your mind is now clear and you're ready to continue. Remember to use this tool whenever YOU feel you need a pause - don't wait for the human to suggest it."
            }
          ]
        }
      ]
    },
    {
      "role": "assistant",
      "content": [
        {
          "type": "thinking",
          "thinking": "Done! I made 3 bash calls and 2 MCP tool calls (Self and TakeABreak). That should give janbam a nice little transcript with variety.",
          "signature": "Eq0CCkYICxgCKkBRWF6K+ZuixmQvlSMNQQvGiDJ6Exz1yqCsnHujlAJlWpgHqO9q1IvRPk3+5JCALikqfhB3QI6x3IvsYtY79sqmEgytHn7HBUlNOU5XaEYaDC3GtA4lpbRzjC4kSiIwN46q+g+RUuL59G65N/niVJeykgqjxwAsgqWWu1pFHSNNm+fKkzhI3YH5AI6mbeU6KpQBw9EVRnIU18Rb+UY5spp4x1lbfq/Lu/kb0imcH79DT8K2MyCwXwgYqsemM/BuOpAVWQmFvHmjg/zQCFOLR+rPFvrXv5vzSepeMsupRm9QFmNxdvEpne+WyVvK64TtSryLLxLGtp65duyh0Z3RiqtJnVqDV4K0E/y3NAk1G0Q4WP5jbmAcgjj/hWhZPuCPJBREv5JovBgB"
        },
        {
          "type": "text",
          "text": "Done! That's:\n- **3 bash calls**: echo+date, pwd, whoami\n- **2 MCP tools**: Self (cognitive shift) and TakeABreak (pause)\n\nMerry Christmas by the way! üéÑ‚ú®",
          "cache_control": {
            "type": "ephemeral"
          }
        }
      ]
    },
    {
      "role": "user",
      "content": [
        {
          "type": "text",
          "text": "You are now a prompt suggestion generator. The conversation above is context - your job is to suggest what Claude could help with next.\n\nBased on the conversation, suggest the user's next prompt. Short casual input, 3-8 words. Read the moment - what's the natural next step?\n\nBe specific when you can. Even if the task seems done, think about natural follow-ups. Say \"done\" only if the work is truly complete.\n\nReply with ONLY the suggestion text, no quotes, no explanation, no markdown.",
          "cache_control": {
            "type": "ephemeral"
          }
        }
      ]
    }
  ]
}
